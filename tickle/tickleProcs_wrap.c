/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.24
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */


#ifndef SWIG_TEMPLATE_DISAMBIGUATOR
#  if defined(__SUNPRO_CC) 
#    define SWIG_TEMPLATE_DISAMBIGUATOR template
#  else
#    define SWIG_TEMPLATE_DISAMBIGUATOR 
#  endif
#endif

/***********************************************************************
 * swigrun.swg
 *
 *     This file contains generic CAPI SWIG runtime support for pointer
 *     type checking.
 *
 ************************************************************************/

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "1"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
#define SWIG_QUOTE_STRING(x) #x
#define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
#define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
#define SWIG_TYPE_TABLE_NAME
#endif

#include <string.h>

#ifndef SWIGINLINE
#if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#  define SWIGINLINE inline
#else
#  define SWIGINLINE
#endif
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the swig runtime code.
  In 99.9% of the cases, swig just needs to declare them as 'static'.
  
  But only do this if is strictly necessary, ie, if you have problems
  with your compiler or so.
*/
#ifndef SWIGRUNTIME
#define SWIGRUNTIME static
#endif
#ifndef SWIGRUNTIMEINLINE
#define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return *f1 - *f2;
  }
  return (l1 - f1) - (l2 - f2);
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te) == 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Register a type mapping with the type-checking
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeRegisterTL(swig_type_info **tl, swig_type_info *ti) {
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = *tl;
  while (tc) {
    /* check simple type equivalence */
    int typeequiv = (strcmp(tc->name, ti->name) == 0);   
    /* check full type equivalence, resolving typedefs */
    if (!typeequiv) {
      /* only if tc is not a typedef (no '|' on it) */
      if (tc->str && ti->str && !strstr(tc->str,"|")) {
	typeequiv = SWIG_TypeEquiv(ti->str,tc->str);
      }
    }
    if (typeequiv) {
      /* Already exists in the table.  Just add additional types to the list */
      if (ti->clientdata) tc->clientdata = ti->clientdata;
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = *tl;
  *tl = ti;

  /* Build linked lists */
  l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;
  head->next = next;

  return ret;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
        s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_type_info *ty, void *ptr) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
  Search for a swig_type_info structure
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryTL(swig_type_info *tl, const char *name) {
  swig_type_info *ty = tl;
  while (ty) {
    if (ty->str && (SWIG_TypeEquiv(ty->str,name))) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientDataTL(swig_type_info *tl, swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata) return;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = tl;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0))
          SWIG_TypeClientDataTL(tl,tc,clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static char hex[17] = "0123456789abcdef";
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  register unsigned char uu;
  for (; u != eu; ++u) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register int d = *(c++);
    register unsigned char uu = 0;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
  This function will propagate the clientdata field of type to any new
  swig_type_info structures that have been added into the list of
  equivalent types.  It is like calling SWIG_TypeClientData(type,
  clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientDataTL(swig_type_info *tl, swig_type_info *type) {
  swig_type_info *equiv = type->next;
  swig_type_info *tc;
  if (!type->clientdata) return;
  while (equiv) {
    if (!equiv->converter) {
      tc = tl;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0) && !tc->clientdata)
          SWIG_TypeClientDataTL(tl,tc, type->clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/


#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  if !defined(STATIC_LINKED)
#    define SWIGEXPORT(a) __declspec(dllexport) a
#  else
#    define SWIGEXPORT(a) a
#  endif
#else
#  define SWIGEXPORT(a) a
#endif

#ifdef __cplusplus
extern "C" {
#endif


/*************************************************************************/


/* The static type info list */

static swig_type_info *swig_type_list = 0;
static swig_type_info **swig_type_list_handle = &swig_type_list;
  

/* Register a type mapping with the type-checking */
static swig_type_info *
SWIG_TypeRegister(swig_type_info *ti) {
  return SWIG_TypeRegisterTL(swig_type_list_handle, ti);
}

/* Search for a swig_type_info structure */
swig_type_info *
SWIG_TypeQuery(const char *name) {
  return SWIG_TypeQueryTL(*swig_type_list_handle, name);
}

/* Set the clientdata field for a type */
static void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientDataTL(*swig_type_list_handle, ti, clientdata);
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
static void
SWIG_PropagateClientData(swig_type_info *type) {
  SWIG_PropagateClientDataTL(*swig_type_list_handle, type);
}

#ifdef __cplusplus
}
#endif

/*
 * $Header$
 * 
 * swigtcl8.swg
 */

#include <tcl.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Constant table */

#define SWIG_TCL_INT     1
#define SWIG_TCL_FLOAT   2
#define SWIG_TCL_STRING  3
#define SWIG_TCL_POINTER 4
#define SWIG_TCL_BINARY  5

/* Flags for pointer conversion */
#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2

/* Swig fail macro */

#define SWIG_fail   goto fail

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

typedef int   (*swig_wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
typedef int   (*swig_wrapper_func)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
typedef char *(*swig_variable_func)(ClientData, Tcl_Interp *, char *, char *, int);
typedef void  (*swig_delete_func)(ClientData);

typedef struct swig_method {
  const char     *name;
  swig_wrapper   method;
} swig_method;

typedef struct swig_attribute {
  const char     *name;
  swig_wrapper   getmethod;
  swig_wrapper   setmethod;
} swig_attribute;

typedef struct swig_class {
  const char         *name;
  swig_type_info   **type;
  swig_wrapper       constructor;
  void              (*destructor)(void *);
  swig_method        *methods;
  swig_attribute     *attributes;
  struct swig_class **bases;
  char              **base_names;
} swig_class;

typedef struct swig_instance {
  Tcl_Obj       *thisptr;
  void          *thisvalue;
  swig_class   *classptr;
  int            destroy;
  Tcl_Command    cmdtok;
} swig_instance;

#define SWIG_NewPointerObj(ptr, type, flags) \
  SWIG_Tcl_NewPointerObj(ptr, type, flags)
#define SWIG_ConvertPtr(oc, ptr, ty, flags) \
  SWIG_Tcl_ConvertPtr(interp, oc, ptr, ty, flags)
#define SWIG_ConvertPtrFromString(c, ptr, ty, flags) \
  SWIG_Tcl_ConvertPtrFromString(interp, c, ptr, ty, flags)
#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
  SWIG_Tcl_ConvertPacked(interp, obj, ptr, sz, ty, flags)
#define SWIG_MakePtr(c, ptr, ty, flags) \
  SWIG_Tcl_MakePtr(c, ptr, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type, flags) \
  SWIG_Tcl_NewPackedObj(ptr, sz, type, flags)
#define SWIG_GetArgs SWIG_Tcl_GetArgs
#define SWIG_PointerTypeFromString(c) \
  SWIG_Tcl_PointerTypeFromString(c)
#define SWIG_Acquire(ptr) \
  SWIG_Tcl_Acquire(ptr)
#define SWIG_Disown(ptr) \
  SWIG_Tcl_Disown(ptr)
#define SWIG_Thisown(ptr) \
  SWIG_Tcl_Thisown(ptr)
#define SWIG_InstallConstants(interp, constants) \
  SWIG_Tcl_InstallConstants(interp, constants)
#define SWIG_GetConstant(key) \
  SWIG_Tcl_GetConstant(key)
#define SWIG_NewInstanceObj(thisvalue, type, flags) \
  SWIG_Tcl_NewInstanceObj(interp, thisvalue, type, flags)
#define SWIG_ObjectConstructor SWIG_Tcl_ObjectConstructor
#define SWIG_MethodCommand SWIG_Tcl_MethodCommand
#define SWIG_ObjectDelete SWIG_Tcl_ObjectDelete

static void 
SWIG_Tcl_LookupTypePointer(Tcl_Interp *interp) {
  char buf[512];
  char *data;
  
  /* first check if pointer already created */
  data = (char *) Tcl_GetVar(interp, "swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, TCL_GLOBAL_ONLY);
  if (data) {
    SWIG_UnpackData(data, &swig_type_list_handle, sizeof(swig_type_info **));
  } else {
    /* create a new pointer */
    data = SWIG_PackData(buf, &swig_type_list_handle, sizeof(swig_type_info **));
    *data = 0;
    Tcl_SetVar(interp, "swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, buf, 0);
  }
}

/* Object support */
static Tcl_HashTable  swigobjectTable;
static int            swigobjectTableinit = 0;

/* Acquire ownership of a pointer */
static void
SWIG_Tcl_Acquire(void *ptr) {
  Tcl_HashEntry *entryPtr;
  int newobj;
  if (!swigobjectTableinit) {
    Tcl_InitHashTable(&swigobjectTable, TCL_ONE_WORD_KEYS);
    swigobjectTableinit = 1;
  }
  entryPtr = Tcl_CreateHashEntry(&swigobjectTable, (char *) ptr, &newobj);
}

/* Disown a pointer.  Returns 1 if we owned it to begin with */
static int
SWIG_Tcl_Disown(void *ptr) {
  Tcl_HashEntry *entryPtr;
  if (!swigobjectTableinit) return 0;
  entryPtr = Tcl_FindHashEntry(&swigobjectTable, (char *) ptr);
  if (entryPtr) {
    Tcl_DeleteHashEntry(entryPtr);
    return 1;
  }
  return 0;
}

static int
SWIG_Tcl_Thisown(void *ptr) {
  if (!swigobjectTableinit) return 0;
  if (Tcl_FindHashEntry(&swigobjectTable, (char *) ptr)) {
    return 1;
  }
  return 0;
}

/* Convert a pointer value */
static int
SWIG_Tcl_ConvertPtrFromString(Tcl_Interp *interp, const char *c, void **ptr, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  /* Pointer values must start with leading underscore */
  while (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) return TCL_OK;
    /* Hmmm. It could be an object name. */
    if (Tcl_VarEval(interp,c," cget -this", (char *) NULL) == TCL_OK) {
      Tcl_Obj *result = Tcl_GetObjResult(interp);
      c = Tcl_GetStringFromObj(result, NULL);
      continue;
    }
    Tcl_ResetResult(interp);
    if (flags & SWIG_POINTER_EXCEPTION) 
      Tcl_SetResult(interp, (char *) "Type error. Expected a pointer", TCL_STATIC);
    return TCL_ERROR;
  }
  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if ((!tc) && (flags & SWIG_POINTER_EXCEPTION)) {
      Tcl_SetResult(interp, (char *) "Type error. Expected ", TCL_STATIC);
      Tcl_AppendElement(interp, (char *) ty->name);
      return TCL_ERROR;
    } else if (!tc) {
      Tcl_ResetResult(interp);
      return TCL_ERROR;
    }
    if (flags & SWIG_POINTER_DISOWN) {
      SWIG_Disown((void *) *ptr);
    }
    *ptr = SWIG_TypeCast(tc,(void *) *ptr);
  }
  return TCL_OK;
}

/* Convert a pointer value */
static SWIGINLINE int
SWIG_Tcl_ConvertPtr(Tcl_Interp *interp, Tcl_Obj *oc, void **ptr, swig_type_info *ty, int flags) {
  return SWIG_Tcl_ConvertPtrFromString(interp, Tcl_GetStringFromObj(oc,NULL), ptr, ty, flags);
}

/* Convert a pointer value */
static char *
SWIG_Tcl_PointerTypeFromString(char *c) {
  char d;
  /* Pointer values must start with leading underscore. NULL has no type */
  if (*c != '_') {
    return 0;
  }
  c++;
  /* Extract hex value from pointer */
  while ((d = *c)) {
    if (!(((d >= '0') && (d <= '9')) || ((d >= 'a') && (d <= 'f')))) break;
    c++;
  }
  return c;
}

/* Convert a packed value value */
static int
SWIG_Tcl_ConvertPacked(Tcl_Interp *interp, Tcl_Obj *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  const char  *c;

  if (!obj) goto type_error;
  c = Tcl_GetStringFromObj(obj,NULL);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return TCL_OK;

type_error:

  if (flags) {
    if (ty) {
      Tcl_SetResult(interp, (char *) "Type error. Expected ", TCL_STATIC);
      Tcl_AppendElement(interp, (char *) ty->name);
      return TCL_ERROR;
    } else {
      Tcl_SetResult(interp, (char *) "Expected packed data.", TCL_STATIC);
      return TCL_ERROR;
    }
  }
  return TCL_ERROR;
}


/* Take a pointer and convert it to a string */
void
SWIG_Tcl_MakePtr(char *c, void *ptr, swig_type_info *ty, int flags) {
  if (ptr) {
    *(c++) = '_';
    c = SWIG_PackData(c,&ptr,sizeof(void *));
    strcpy(c,ty->name);
  } else {
    strcpy(c,(char *)"NULL");
  }
  flags = 0;
}

/* Create a new pointer object */
static SWIGINLINE Tcl_Obj *
SWIG_Tcl_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
  Tcl_Obj *robj;
  char result[512];
  SWIG_MakePtr(result,ptr,type,flags);
  robj = Tcl_NewStringObj(result,-1);
  return robj;
}

static Tcl_Obj *
SWIG_Tcl_NewPackedObj(void *ptr, int sz, swig_type_info *type, int flags) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  flags = 0;
  return Tcl_NewStringObj(result,-1);
}

static Tcl_HashTable   swigconstTable;
static int             swigconstTableinit = 0;

/* Install Constants */
static void
SWIG_Tcl_InstallConstants(Tcl_Interp *interp, swig_const_info constants[]) {
  int i;
  Tcl_Obj *obj;
  Tcl_HashEntry *entryPtr;
  int            newobj;

  if (!swigconstTableinit) {
    Tcl_InitHashTable(&swigconstTable, TCL_STRING_KEYS);
    swigconstTableinit = 1;
  }
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_TCL_INT:
      obj = Tcl_NewIntObj(constants[i].lvalue);
      break;
    case SWIG_TCL_FLOAT:
      obj = Tcl_NewDoubleObj(constants[i].dvalue);
      break;
    case SWIG_TCL_STRING:
      obj = Tcl_NewStringObj((char *) constants[i].pvalue,-1);
      break;
    case SWIG_TCL_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_TCL_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype),0);
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      Tcl_ObjSetVar2(interp,Tcl_NewStringObj(constants[i].name,-1), NULL, obj, TCL_GLOBAL_ONLY);
      entryPtr = Tcl_CreateHashEntry(&swigconstTable, constants[i].name, &newobj);
      Tcl_SetHashValue(entryPtr, (ClientData) obj);
    }
  }
}

static Tcl_Obj *
SWIG_Tcl_GetConstant(const char *key) {
  Tcl_HashEntry *entryPtr;
  if (!swigconstTableinit) return 0;
  entryPtr = Tcl_FindHashEntry(&swigconstTable, key);
  if (entryPtr) {
    return (Tcl_Obj *) Tcl_GetHashValue(entryPtr);
  }
  printf("Searching %s\n", key);
  return 0;
}

/* Get arguments */
static int
SWIG_Tcl_GetArgs(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], const char *fmt, ...) {
  int        argno = 0, opt = 0;
  long       tempi;
  double     tempd;
  const char *c;
  va_list    ap;
  void      *vptr;
  Tcl_Obj   *obj = 0;
  swig_type_info *ty;

  va_start(ap,fmt);
  for (c = fmt; (*c && (*c != ':') && (*c != ';')); c++,argno++) {
    if (*c == '|') {
      opt = 1;
      c++;
    }
    if (argno >= (objc-1)) {
      if (!opt) {
        Tcl_SetResult(interp, (char *) "Wrong # args. ", TCL_STATIC);
        goto argerror;
      } else {
        va_end(ap);
        return TCL_OK;
      }
    }

    vptr = va_arg(ap,void *);
    if (vptr) {
      if (isupper(*c)) {
        obj = SWIG_GetConstant(Tcl_GetStringFromObj(objv[argno+1],0));
        if (!obj) obj = objv[argno+1];
      } else {
        obj = objv[argno+1];
      }
      switch(*c) {
      case 'i': case 'I':
      case 'l': case 'L':
      case 'h': case 'H':
      case 'b': case 'B':
        if (Tcl_GetLongFromObj(interp,obj,&tempi) != TCL_OK) goto argerror;
        if ((*c == 'i') || (*c == 'I')) *((int *)vptr) = (int)tempi;
        else if ((*c == 'l') || (*c == 'L')) *((long *)vptr) = (long)tempi;
        else if ((*c == 'h') || (*c == 'H')) *((short*)vptr) = (short)tempi;
        else if ((*c == 'b') || (*c == 'B')) *((unsigned char *)vptr) = (unsigned char)tempi;
        break;
      case 'f': case 'F':
      case 'd': case 'D':
        if (Tcl_GetDoubleFromObj(interp,obj,&tempd) != TCL_OK) goto argerror;
        if ((*c == 'f') || (*c == 'F')) *((float *) vptr) = (float)tempd;
        else if ((*c == 'd') || (*c == 'D')) *((double*) vptr) = tempd;
        break;
      case 's': case 'S':
        if (*(c+1) == '#') {
          int *vlptr = (int *) va_arg(ap, void *);
          *((char **) vptr) = Tcl_GetStringFromObj(obj, vlptr);
          c++;
        } else {
          *((char **)vptr) = Tcl_GetStringFromObj(obj,NULL);
        }
        break;
      case 'c': case 'C':
        *((char *)vptr) = *(Tcl_GetStringFromObj(obj,NULL));
        break;
      case 'p': case 'P':
        ty = (swig_type_info *) va_arg(ap, void *);
        if (SWIG_Tcl_ConvertPtr(interp, obj, (void **) vptr, ty, SWIG_POINTER_EXCEPTION) == TCL_ERROR) goto argerror;
        break;
      case 'o': case 'O':
        *((Tcl_Obj **)vptr) = objv[argno+1];
        break;
      default:
        break;
      }
    }
  }

  if ((*c != ';') && ((objc-1) > argno)) {
    Tcl_SetResult(interp, (char *) "Wrong # args.", TCL_STATIC);
    goto argerror;
  }
  va_end(ap);
  return TCL_OK;

 argerror:
  {
    char temp[32];
    sprintf(temp,"%d", argno+1);
    c = strchr(fmt,':');
    if (!c) c = strchr(fmt,';');
    if (!c) c = (char *)"";
    Tcl_AppendResult(interp,c," argument ", temp, NULL);
    va_end(ap);
    return TCL_ERROR;
  }
}

static void
SWIG_Tcl_ObjectDelete(ClientData clientData) {
  swig_instance *si = (swig_instance *) clientData;
  if ((si) && (si->destroy) && (SWIG_Disown(si->thisvalue))) {
    if (si->classptr->destructor) {
      (si->classptr->destructor)(si->thisvalue);
    }
  }
  Tcl_DecrRefCount(si->thisptr);
  free(si);
}

/* Function to invoke object methods given an instance */
static int
SWIG_Tcl_MethodCommand(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST _objv[]) {
  char *method,   *attrname;
  swig_instance   *inst = (swig_instance *) clientData;
  swig_method     *meth;
  swig_attribute  *attr;
  Tcl_Obj         *oldarg;
  Tcl_Obj         **objv;
  int              rcode;
  swig_class      *cls;
  swig_class      *cls_stack[64];
  int              cls_stack_bi[64];
  int              cls_stack_top = 0;
  int              numconf = 2;
  int              bi;

  objv = (Tcl_Obj **) _objv;
  if (objc < 2) {
    Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
    return TCL_ERROR;
  }
  method = Tcl_GetStringFromObj(objv[1],NULL);
  if (strcmp(method,"-acquire") == 0) {
    inst->destroy = 1;
    SWIG_Acquire(inst->thisvalue);
    return TCL_OK;
  }
  if (strcmp(method,"-disown") == 0) {
    if (inst->destroy) {
      SWIG_Disown(inst->thisvalue);
    }
    inst->destroy = 0;
    return TCL_OK;
  }
  if (strcmp(method,"-delete") == 0) {
    Tcl_DeleteCommandFromToken(interp,inst->cmdtok);
    return TCL_OK;
  }
  cls_stack[cls_stack_top] = inst->classptr;
  cls_stack_bi[cls_stack_top] = -1;
  cls = inst->classptr;
  while (1) {
    bi = cls_stack_bi[cls_stack_top];
    cls = cls_stack[cls_stack_top];
    if (bi != -1) {
      if (!cls->bases[bi] && cls->base_names[bi]) {
        /* lookup and cache the base class */
	swig_type_info *info = SWIG_TypeQuery(cls->base_names[bi]);
	if (info) cls->bases[bi] = (swig_class *) info->clientdata;
      }
      cls = cls->bases[bi];
      if (cls) {
        cls_stack_bi[cls_stack_top]++;
        cls_stack_top++;
        cls_stack[cls_stack_top] = cls;
        cls_stack_bi[cls_stack_top] = -1;
        continue;
      }
    }
    if (!cls) {
      cls_stack_top--;
      if (cls_stack_top < 0) break;
      else continue;
    }
    cls_stack_bi[cls_stack_top]++;

    meth = cls->methods;
    /* Check for methods */
    while (meth && meth->name) {
      if (strcmp(meth->name,method) == 0) {
        oldarg = objv[1];
        objv[1] = inst->thisptr;
        Tcl_IncrRefCount(inst->thisptr);
        rcode = (*meth->method)(clientData,interp,objc,objv);
        objv[1] = oldarg;
        Tcl_DecrRefCount(inst->thisptr);
        return rcode;
      }
      meth++;
    }
    /* Check class methods for a match */
    if (strcmp(method,"cget") == 0) {
      if (objc < 3) {
        Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
        return TCL_ERROR;
      }
      attrname = Tcl_GetStringFromObj(objv[2],NULL);
      attr = cls->attributes;
      while (attr && attr->name) {
        if ((strcmp(attr->name, attrname) == 0) && (attr->getmethod)) {
          oldarg = objv[1];
          objv[1] = inst->thisptr;
          Tcl_IncrRefCount(inst->thisptr);
          rcode = (*attr->getmethod)(clientData,interp,2, objv);
          objv[1] = oldarg;
          Tcl_DecrRefCount(inst->thisptr);
          return rcode;
        }
        attr++;
      }
      if (strcmp(attrname, "-this") == 0) {
        Tcl_SetObjResult(interp, Tcl_DuplicateObj(inst->thisptr));
        return TCL_OK;
      }
      if (strcmp(attrname, "-thisown") == 0) {
        if (SWIG_Thisown(inst->thisvalue)) {
          Tcl_SetResult(interp,(char*)"1",TCL_STATIC);
        } else {
          Tcl_SetResult(interp,(char*)"0",TCL_STATIC);
        }
        return TCL_OK;
      }
    } else if (strcmp(method, "configure") == 0) {
      int i;
      if (objc < 4) {
        Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
        return TCL_ERROR;
      }
      i = 2;
      while (i < objc) {
        attrname = Tcl_GetStringFromObj(objv[i],NULL);
        attr = cls->attributes;
        while (attr && attr->name) {
          if ((strcmp(attr->name, attrname) == 0) && (attr->setmethod)) {
            oldarg = objv[i];
            objv[i] = inst->thisptr;
            Tcl_IncrRefCount(inst->thisptr);
            rcode = (*attr->setmethod)(clientData,interp,3, &objv[i-1]);
            objv[i] = oldarg;
            Tcl_DecrRefCount(inst->thisptr);
            if (rcode != TCL_OK) return rcode;
            numconf += 2;
          }
          attr++;
        }
        i+=2;
      }
    }
  }
  if (strcmp(method,"configure") == 0) {
    if (numconf >= objc) {
      return TCL_OK;
    } else {
      Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
      return TCL_ERROR;
    }
  }
  if (strcmp(method,"cget") == 0) {
      Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
      return TCL_ERROR;
  }

  Tcl_SetResult(interp, (char *) "Invalid method. Must be one of: configure cget -acquire -disown -delete", TCL_STATIC);
  cls = inst->classptr;
  bi = 0;
  while (cls) {
    meth = cls->methods;
    while (meth && meth->name) {
      char *cr = (char *) Tcl_GetStringResult(interp);
      if (!strstr(strchr(cr,':'), meth->name))
        Tcl_AppendElement(interp, (char *) meth->name);
      meth++;
    }
    cls = inst->classptr->bases[bi++];
  }
  return TCL_ERROR;
}

/* Function to create objects */
static int
SWIG_Tcl_ObjectConstructor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj          *newObj = 0;
    void             *thisvalue = 0;
    swig_instance   *newinst = 0;
    swig_class      *classptr = (swig_class *) clientData;
    swig_wrapper     cons = 0;
    char             *name = 0;
    int               firstarg = 0;
    int               thisarg = 0;
    int               destroy = 1;

    if (!classptr) {
      Tcl_SetResult(interp, (char *) "swig: internal runtime error. No class object defined.", TCL_STATIC);
      return TCL_ERROR;
    }
    cons = classptr->constructor;
    if (objc > 1) {
      char *s = Tcl_GetStringFromObj(objv[1],NULL);
      if (strcmp(s,"-this") == 0) {
        thisarg = 2;
        cons = 0;
      } else if (strcmp(s,"-args") == 0) {
        firstarg = 1;
      } else if (objc == 2) {
        firstarg = 1;
        name = s;
      } else if (objc >= 3) {
        char *s1;
        name = s;
        s1 = Tcl_GetStringFromObj(objv[2],NULL);
        if (strcmp(s1,"-this") == 0) {
          thisarg = 3;
          cons = 0;
        } else {
          firstarg = 1;
        }
      }
    }
    if (cons) {
      int result;
      result = (*cons)(0, interp, objc-firstarg, &objv[firstarg]);
      if (result != TCL_OK) {
        return result;
      }
      newObj = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
      if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
    } else if (thisarg > 0) {
      if (thisarg < objc) {
        destroy = 0;
        newObj = Tcl_DuplicateObj(objv[thisarg]);
        if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
      } else {
        Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
        return TCL_ERROR;
      }
    } else {
      Tcl_SetResult(interp, (char *) "No constructor available.", TCL_STATIC);
      return TCL_ERROR;
    }
    if (SWIG_Tcl_ConvertPtr(interp,newObj, (void **) &thisvalue, *(classptr->type), SWIG_POINTER_EXCEPTION) == TCL_ERROR) {
      Tcl_DecrRefCount(newObj);
      return TCL_ERROR;
    }
    newinst = (swig_instance *) malloc(sizeof(swig_instance));
    newinst->thisptr = newObj;
    Tcl_IncrRefCount(newObj);
    newinst->thisvalue = thisvalue;
    newinst->classptr = classptr;
    newinst->destroy = destroy;
    if (destroy) {
      SWIG_Acquire(thisvalue);
    }
    newinst->cmdtok = Tcl_CreateObjCommand(interp,name, (swig_wrapper) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
    return TCL_OK;
}


/* This function takes the current result and turns it into an object command */
static Tcl_Obj *
SWIG_Tcl_NewInstanceObj(Tcl_Interp *interp, void *thisvalue, swig_type_info *type, int flags) {
  Tcl_Obj *robj = SWIG_NewPointerObj(thisvalue, type,0);
  /* Check to see if this pointer belongs to a class or not */
  if ((type->clientdata) && (interp)) {
    Tcl_CmdInfo    ci;
    char          *name;
    name = Tcl_GetStringFromObj(robj,NULL);
    if (!Tcl_GetCommandInfo(interp,name, &ci) || (flags)) {
      swig_instance *newinst = (swig_instance *) malloc(sizeof(swig_instance));
      newinst->thisptr = Tcl_DuplicateObj(robj);
      Tcl_IncrRefCount(newinst->thisptr);
      newinst->thisvalue = thisvalue;
      newinst->classptr = (swig_class *) type->clientdata;
      newinst->destroy = flags;
      newinst->cmdtok = Tcl_CreateObjCommand(interp, Tcl_GetStringFromObj(robj,NULL), (swig_wrapper_func) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
      if (flags) {
        SWIG_Acquire(thisvalue);
      }
    }
  }
  return robj;
}

/* Structure for command table */
typedef struct {
  const char *name;
  int       (*wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
  ClientData  clientdata;
} swig_command_info;

/* Structure for variable linking table */
typedef struct {
  const char *name;
  void *addr;
  char * (*get)(ClientData, Tcl_Interp *, char *, char *, int);
  char * (*set)(ClientData, Tcl_Interp *, char *, char *, int);
} swig_var_info;


/* Contract support */

#define SWIG_contract_assert(expr, msg)  if (!(expr)) { Tcl_SetResult(interp, (char *) msg, TCL_STATIC ); goto fail; } else

#ifdef __cplusplus
}
#endif






/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_Tcl_Encoding swig_types[0] 
#define  SWIGTYPE_size_t swig_types[1] 
#define  SWIGTYPE_ptrdiff_t swig_types[2] 
static swig_type_info *swig_types[4];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Bnc_Init
#define SWIG_name    "bnc"
#define SWIG_prefix  ""
#define SWIG_version "0.4"


#ifdef __cplusplus
extern "C" {
#endif
#ifdef MAC_TCL
#pragma export on
#endif
SWIGEXPORT(int) SWIG_init(Tcl_Interp *);
#ifdef MAC_TCL
#pragma export off
#endif
#ifdef __cplusplus
}
#endif



#include "tickleProcs.h"


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


#define SWIG_exception(a,b)   { Tcl_SetResult(interp,b,TCL_VOLATILE); SWIG_fail; }

extern Tcl_Encoding g_Encoding;
#ifdef __cplusplus
extern "C" {
#endif
static char *_wrap_g_Encoding_get(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags) {
    Tcl_Obj *value = 0;
    
    value = SWIG_NewInstanceObj((void *) &g_Encoding, SWIGTYPE_p_Tcl_Encoding,0);
    if (value) {
        Tcl_SetVar2(interp,name1,name2,Tcl_GetStringFromObj(value,NULL), flags);
        Tcl_DecrRefCount(value);
    }
    return NULL;
}


static char *_wrap_g_Encoding_set(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags) {
    Tcl_Obj *value = 0;
    Tcl_Obj *name1o = 0;
    
    name1o = Tcl_NewStringObj(name1,-1);
    value = Tcl_ObjGetVar2(interp, name1o, 0, flags);
    Tcl_DecrRefCount(name1o);
    if (!value) return NULL;
    {
        void *temp;
        if (SWIG_ConvertPtr(value,&temp,SWIGTYPE_p_Tcl_Encoding, SWIG_POINTER_EXCEPTION) != TCL_OK) {
            return (char*)"Type error. Expected Tcl_Encoding *";
        }
        g_Encoding = *((Tcl_Encoding *) temp);
    }
    return NULL;
}


static int
_wrap_putclient(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:putclient text ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (int)putclient((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_simul(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:simul User Command ",NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    {
        try {
            result = (int)simul((char const *)arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}


static int
_wrap_internalbind(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    Tcl_DString ds_3 ;
    bool ds_use_3 = false ;
    Tcl_DString ds_4 ;
    bool ds_use_4 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo|oo:internalbind type proc ?pattern? ?user? ",NULL,NULL,NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    if (objc > 3) {
        {
            ds_use_3 = true;
            arg3 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[3]), -1, &ds_3);
        }
    }
    if (objc > 4) {
        {
            ds_use_4 = true;
            arg4 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[4]), -1, &ds_4);
        }
    }
    {
        try {
            result = (int)internalbind((char const *)arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    {
        if (ds_use_4)
        Tcl_DStringFree(&ds_4);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    {
        if (ds_use_4)
        Tcl_DStringFree(&ds_4);
    }
    return TCL_ERROR;
}


static int
_wrap_internalunbind(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    Tcl_DString ds_3 ;
    bool ds_use_3 = false ;
    Tcl_DString ds_4 ;
    bool ds_use_4 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo|oo:internalunbind type proc ?pattern? ?user? ",NULL,NULL,NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    if (objc > 3) {
        {
            ds_use_3 = true;
            arg3 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[3]), -1, &ds_3);
        }
    }
    if (objc > 4) {
        {
            ds_use_4 = true;
            arg4 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[4]), -1, &ds_4);
        }
    }
    {
        try {
            result = (int)internalunbind((char const *)arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    {
        if (ds_use_4)
        Tcl_DStringFree(&ds_4);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    {
        if (ds_use_4)
        Tcl_DStringFree(&ds_4);
    }
    return TCL_ERROR;
}


static int
_wrap_setctx(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:setctx ctx ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            setctx((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_getctx(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":getctx ") == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (char *)getctx();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_bncuserlist(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":bncuserlist ") == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (char *)bncuserlist();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_getbncuser(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    Tcl_DString ds_3 ;
    bool ds_use_3 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo|o:getbncuser User Type ?Parameter2? ",NULL,NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    if (objc > 3) {
        {
            ds_use_3 = true;
            arg3 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[3]), -1, &ds_3);
        }
    }
    {
        try {
            result = (char *)getbncuser((char const *)arg1,(char const *)arg2,(char const *)arg3);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    return TCL_ERROR;
}


static int
_wrap_setbncuser(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    Tcl_DString ds_3 ;
    bool ds_use_3 = false ;
    Tcl_DString ds_4 ;
    bool ds_use_4 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo|oo:setbncuser User Type ?Value? ?Parameter2? ",NULL,NULL,NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    if (objc > 3) {
        {
            ds_use_3 = true;
            arg3 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[3]), -1, &ds_3);
        }
    }
    if (objc > 4) {
        {
            ds_use_4 = true;
            arg4 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[4]), -1, &ds_4);
        }
    }
    {
        try {
            result = (int)setbncuser((char const *)arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    {
        if (ds_use_4)
        Tcl_DStringFree(&ds_4);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    {
        if (ds_use_4)
        Tcl_DStringFree(&ds_4);
    }
    return TCL_ERROR;
}


static int
_wrap_addbncuser(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:addbncuser User Password ",NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    {
        try {
            addbncuser((char const *)arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}


static int
_wrap_delbncuser(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:delbncuser User ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            delbncuser((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_bnccheckpassword(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    bool result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:bnccheckpassword User Password ",NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    {
        try {
            result = (bool)bnccheckpassword((char const *)arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}


static int
_wrap_internalchanlist(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:internalchanlist Channel ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (char *)internalchanlist((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_bncversion(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":bncversion ") == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (char *)bncversion();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_bncnumversion(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":bncnumversion ") == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (char *)bncnumversion();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_bncuptime(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,":bncuptime ") == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (int)bncuptime();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_floodcontrol(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:floodcontrol Function ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (int)floodcontrol((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_getisupport(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:getisupport Feature ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (char *)getisupport((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_requiresparam(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char arg1 ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"c:requiresparam Mode ",&arg1) == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (int)requiresparam(arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_isprefixmode(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char arg1 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"c:isprefixmode Mode ",&arg1) == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (bool)isprefixmode(arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_getchanprefix(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    char *result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:getchanprefix Channel Nick ",NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    {
        try {
            result = (char *)getchanprefix((char const *)arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}


static int
_wrap_internalchannels(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":internalchannels ") == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (char *)internalchannels();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_bncmodules(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":bncmodules ") == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (char *)bncmodules();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_bncsettag(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    Tcl_DString ds_3 ;
    bool ds_use_3 = false ;
    Tcl_DString ds_4 ;
    bool ds_use_4 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oooo:bncsettag channel nick tag value ",NULL,NULL,NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    {
        ds_use_3 = true;
        arg3 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[3]), -1, &ds_3);
    }
    {
        ds_use_4 = true;
        arg4 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[4]), -1, &ds_4);
    }
    {
        try {
            result = (int)bncsettag((char const *)arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    {
        if (ds_use_4)
        Tcl_DStringFree(&ds_4);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    {
        if (ds_use_4)
        Tcl_DStringFree(&ds_4);
    }
    return TCL_ERROR;
}


static int
_wrap_bncgettag(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    Tcl_DString ds_3 ;
    bool ds_use_3 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:bncgettag channel nick tag ",NULL,NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    {
        ds_use_3 = true;
        arg3 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[3]), -1, &ds_3);
    }
    {
        try {
            result = (char *)bncgettag((char const *)arg1,(char const *)arg2,(char const *)arg3);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    return TCL_ERROR;
}


static int
_wrap_haltoutput(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    if (SWIG_GetArgs(interp, objc, objv,":haltoutput ") == TCL_ERROR) SWIG_fail;
    {
        try {
            haltoutput();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_bnccommand(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    char *result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:bnccommand Cmd Parameters ",NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    {
        try {
            result = (char *)bnccommand((char const *)arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}


static int
_wrap_md5(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:md5 String ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (char *)md5((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_debugout(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:debugout String ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            debugout((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_internalgetchanidle(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:internalgetchanidle Nick Channel ",NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    {
        try {
            result = (int)internalgetchanidle((char const *)arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}


static int
_wrap_bncreply(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:bncreply Text ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            bncreply((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_trafficstats(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) NULL ;
    char *arg3 = (char *) NULL ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    Tcl_DString ds_3 ;
    bool ds_use_3 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o|oo:trafficstats User ?ConnectionType? ?Type? ",NULL,NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    if (objc > 2) {
        {
            ds_use_2 = true;
            arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
        }
    }
    if (objc > 3) {
        {
            ds_use_3 = true;
            arg3 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[3]), -1, &ds_3);
        }
    }
    {
        try {
            result = (int)trafficstats((char const *)arg1,(char const *)arg2,(char const *)arg3);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    return TCL_ERROR;
}


static int
_wrap_bncjoinchans(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:bncjoinchans User ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            bncjoinchans((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_internallisten(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    unsigned short arg1 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    int result;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    Tcl_DString ds_3 ;
    bool ds_use_3 = false ;
    Tcl_DString ds_4 ;
    bool ds_use_4 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ho|oo:internallisten Port Type ?Options? ?Flag? ",&arg1,NULL,NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    if (objc > 3) {
        {
            ds_use_3 = true;
            arg3 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[3]), -1, &ds_3);
        }
    }
    if (objc > 4) {
        {
            ds_use_4 = true;
            arg4 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[4]), -1, &ds_4);
        }
    }
    {
        try {
            result = (int)internallisten(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    {
        if (ds_use_4)
        Tcl_DStringFree(&ds_4);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    {
        if (ds_use_4)
        Tcl_DStringFree(&ds_4);
    }
    return TCL_ERROR;
}


static int
_wrap_internalsocketwriteln(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    int arg1 ;
    char *arg2 = (char *) 0 ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"io:internalsocketwriteln Socket Line ",&arg1,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    {
        try {
            internalsocketwriteln(arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}


static int
_wrap_internalconnect(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    unsigned short arg2 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oh:internalconnect Host Port ",NULL,&arg2) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (int)internalconnect((char const *)arg1,arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_internalclosesocket(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    int arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"i:internalclosesocket Socket ",&arg1) == TCL_ERROR) SWIG_fail;
    {
        try {
            internalclosesocket(arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_internaltimer(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    int arg1 ;
    bool arg2 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    int result;
    int tempb2 ;
    Tcl_DString ds_3 ;
    bool ds_use_3 = false ;
    Tcl_DString ds_4 ;
    bool ds_use_4 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ioo|o:internaltimer Interval Repeat Proc ?Parameter? ",&arg1,NULL,NULL,NULL) == TCL_ERROR) SWIG_fail;
    if (Tcl_GetIntFromObj(interp,objv[2],&tempb2) == TCL_ERROR) SWIG_fail;
    arg2 = tempb2 ? true : false;
    {
        ds_use_3 = true;
        arg3 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[3]), -1, &ds_3);
    }
    if (objc > 4) {
        {
            ds_use_4 = true;
            arg4 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[4]), -1, &ds_4);
        }
    }
    {
        try {
            result = (int)internaltimer(arg1,arg2,(char const *)arg3,(char const *)arg4);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    {
        if (ds_use_4)
        Tcl_DStringFree(&ds_4);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_3)
        Tcl_DStringFree(&ds_3);
    }
    {
        if (ds_use_4)
        Tcl_DStringFree(&ds_4);
    }
    return TCL_ERROR;
}


static int
_wrap_internalkilltimer(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o|o:internalkilltimer Proc ?Parameter? ",NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    if (objc > 2) {
        {
            ds_use_2 = true;
            arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
        }
    }
    {
        try {
            result = (int)internalkilltimer((char const *)arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}


static int
_wrap_timerstats(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,":timerstats ") == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (int)timerstats();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_bncdisconnect(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:bncdisconnect Reason ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            bncdisconnect((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_bnckill(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:bnckill Reason ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            bnckill((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_getcurrentnick(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":getcurrentnick ") == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (char *)getcurrentnick();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_internalbinds(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":internalbinds ") == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (char *)internalbinds();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_bncgetmotd(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":bncgetmotd ") == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (char *)bncgetmotd();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_bncsetmotd(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:bncsetmotd Motd ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            bncsetmotd((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_bncgetgvhost(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":bncgetgvhost ") == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (char *)bncgetgvhost();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_bncsetgvhost(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:bncsetgvhost GVHost ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            bncsetgvhost((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_getbnchosts(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":getbnchosts ") == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (char *)getbnchosts();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_delbnchost(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:delbnchost Host ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            delbnchost((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_addbnchost(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:addbnchost Host ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (int)addbnchost((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_bncisipblocked(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    bool result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:bncisipblocked Ip ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (bool)bncisipblocked((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_bnccanhostconnect(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    bool result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:bnccanhostconnect Host ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (bool)bnccanhostconnect((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_bncvalidusername(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    bool result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:bncvalidusername Name ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (bool)bncvalidusername((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_onchan(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    bool result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o|o:onchan Nick ?Channel? ",NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    if (objc > 2) {
        {
            ds_use_2 = true;
            arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
        }
    }
    {
        try {
            result = (bool)onchan((char const *)arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}


static int
_wrap_topic(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:topic Channel ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (char *)topic((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_topicnick(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:topicnick Channel ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (char *)topicnick((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_topicstamp(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:topicstamp Channel ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (int)topicstamp((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_getchanmode(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:getchanmode Channel ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (char *)getchanmode((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_isop(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    bool result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o|o:isop Nick ?Channel? ",NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    if (objc > 2) {
        {
            ds_use_2 = true;
            arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
        }
    }
    {
        try {
            result = (bool)isop((char const *)arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}


static int
_wrap_isvoice(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    bool result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o|o:isvoice Nick ?Channel? ",NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    if (objc > 2) {
        {
            ds_use_2 = true;
            arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
        }
    }
    {
        try {
            result = (bool)isvoice((char const *)arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}


static int
_wrap_ishalfop(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    bool result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o|o:ishalfop Nick ?Channel? ",NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    if (objc > 2) {
        {
            ds_use_2 = true;
            arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
        }
    }
    {
        try {
            result = (bool)ishalfop((char const *)arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}


static int
_wrap_getchanhost(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    char *result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o|o:getchanhost Nick ?Channel? ",NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    if (objc > 2) {
        {
            ds_use_2 = true;
            arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
        }
    }
    {
        try {
            result = (char *)getchanhost((char const *)arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}


static int
_wrap_jump(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    if (SWIG_GetArgs(interp, objc, objv,":jump ") == TCL_ERROR) SWIG_fail;
    {
        try {
            jump();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_rehash(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    if (SWIG_GetArgs(interp, objc, objv,":rehash ") == TCL_ERROR) SWIG_fail;
    {
        try {
            rehash();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_die(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    if (SWIG_GetArgs(interp, objc, objv,":die ") == TCL_ERROR) SWIG_fail;
    {
        try {
            die();
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_putserv(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:putserv text ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (int)putserv((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_getchanjoin(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:getchanjoin Nick Channel ",NULL,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    {
        try {
            result = (int)getchanjoin((char const *)arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}


static int
_wrap_rand(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    int arg1 ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"i:rand limit ",&arg1) == TCL_ERROR) SWIG_fail;
    {
        try {
            result = (int)ticklerand(arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_clearqueue(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:clearqueue Queue ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (int)clearqueue((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_queuesize(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:queuesize Queue ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (int)queuesize((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_puthelp(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:puthelp text ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (int)puthelp((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_putquick(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    int result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:putquick text ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (int)putquick((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_putlog(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:putlog Text ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            putlog((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_chanbans(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 = (char *) 0 ;
    char *result;
    Tcl_DString ds_1 ;
    bool ds_use_1 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:chanbans Channel ",NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_1 = true;
        arg1 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[1]), -1, &ds_1);
    }
    {
        try {
            result = (char *)chanbans((char const *)arg1);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    {
        Tcl_DString ds_result;
        
        Tcl_SetObjResult(interp,Tcl_NewStringObj(Tcl_ExternalToUtfDString(g_Encoding, result, -1, &ds_result),-1));
        Tcl_DStringFree(&ds_result);
    }
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_1)
        Tcl_DStringFree(&ds_1);
    }
    return TCL_ERROR;
}


static int
_wrap_control(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    int arg1 ;
    char *arg2 = (char *) 0 ;
    Tcl_DString ds_2 ;
    bool ds_use_2 = false ;
    
    if (SWIG_GetArgs(interp, objc, objv,"io:control Socket Proc ",&arg1,NULL) == TCL_ERROR) SWIG_fail;
    {
        ds_use_2 = true;
        arg2 = Tcl_UtfToExternalDString(g_Encoding, Tcl_GetString(objv[2]), -1, &ds_2);
    }
    {
        try {
            control(arg1,(char const *)arg2);
            
        } catch (const char* p) {
            SWIG_exception(SWIG_RuntimeError, const_cast<char*>(p));
        }
    }
    
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_OK;
    fail:
    {
        if (ds_use_2)
        Tcl_DStringFree(&ds_2);
    }
    return TCL_ERROR;
}



static swig_command_info swig_commands[] = {
    { SWIG_prefix "putclient", (swig_wrapper_func) _wrap_putclient, NULL},
    { SWIG_prefix "simul", (swig_wrapper_func) _wrap_simul, NULL},
    { SWIG_prefix "internalbind", (swig_wrapper_func) _wrap_internalbind, NULL},
    { SWIG_prefix "internalunbind", (swig_wrapper_func) _wrap_internalunbind, NULL},
    { SWIG_prefix "setctx", (swig_wrapper_func) _wrap_setctx, NULL},
    { SWIG_prefix "getctx", (swig_wrapper_func) _wrap_getctx, NULL},
    { SWIG_prefix "bncuserlist", (swig_wrapper_func) _wrap_bncuserlist, NULL},
    { SWIG_prefix "getbncuser", (swig_wrapper_func) _wrap_getbncuser, NULL},
    { SWIG_prefix "setbncuser", (swig_wrapper_func) _wrap_setbncuser, NULL},
    { SWIG_prefix "addbncuser", (swig_wrapper_func) _wrap_addbncuser, NULL},
    { SWIG_prefix "delbncuser", (swig_wrapper_func) _wrap_delbncuser, NULL},
    { SWIG_prefix "bnccheckpassword", (swig_wrapper_func) _wrap_bnccheckpassword, NULL},
    { SWIG_prefix "internalchanlist", (swig_wrapper_func) _wrap_internalchanlist, NULL},
    { SWIG_prefix "bncversion", (swig_wrapper_func) _wrap_bncversion, NULL},
    { SWIG_prefix "bncnumversion", (swig_wrapper_func) _wrap_bncnumversion, NULL},
    { SWIG_prefix "bncuptime", (swig_wrapper_func) _wrap_bncuptime, NULL},
    { SWIG_prefix "floodcontrol", (swig_wrapper_func) _wrap_floodcontrol, NULL},
    { SWIG_prefix "getisupport", (swig_wrapper_func) _wrap_getisupport, NULL},
    { SWIG_prefix "requiresparam", (swig_wrapper_func) _wrap_requiresparam, NULL},
    { SWIG_prefix "isprefixmode", (swig_wrapper_func) _wrap_isprefixmode, NULL},
    { SWIG_prefix "getchanprefix", (swig_wrapper_func) _wrap_getchanprefix, NULL},
    { SWIG_prefix "internalchannels", (swig_wrapper_func) _wrap_internalchannels, NULL},
    { SWIG_prefix "bncmodules", (swig_wrapper_func) _wrap_bncmodules, NULL},
    { SWIG_prefix "bncsettag", (swig_wrapper_func) _wrap_bncsettag, NULL},
    { SWIG_prefix "bncgettag", (swig_wrapper_func) _wrap_bncgettag, NULL},
    { SWIG_prefix "haltoutput", (swig_wrapper_func) _wrap_haltoutput, NULL},
    { SWIG_prefix "bnccommand", (swig_wrapper_func) _wrap_bnccommand, NULL},
    { SWIG_prefix "md5", (swig_wrapper_func) _wrap_md5, NULL},
    { SWIG_prefix "debugout", (swig_wrapper_func) _wrap_debugout, NULL},
    { SWIG_prefix "internalgetchanidle", (swig_wrapper_func) _wrap_internalgetchanidle, NULL},
    { SWIG_prefix "bncreply", (swig_wrapper_func) _wrap_bncreply, NULL},
    { SWIG_prefix "trafficstats", (swig_wrapper_func) _wrap_trafficstats, NULL},
    { SWIG_prefix "bncjoinchans", (swig_wrapper_func) _wrap_bncjoinchans, NULL},
    { SWIG_prefix "internallisten", (swig_wrapper_func) _wrap_internallisten, NULL},
    { SWIG_prefix "internalsocketwriteln", (swig_wrapper_func) _wrap_internalsocketwriteln, NULL},
    { SWIG_prefix "internalconnect", (swig_wrapper_func) _wrap_internalconnect, NULL},
    { SWIG_prefix "internalclosesocket", (swig_wrapper_func) _wrap_internalclosesocket, NULL},
    { SWIG_prefix "internaltimer", (swig_wrapper_func) _wrap_internaltimer, NULL},
    { SWIG_prefix "internalkilltimer", (swig_wrapper_func) _wrap_internalkilltimer, NULL},
    { SWIG_prefix "timerstats", (swig_wrapper_func) _wrap_timerstats, NULL},
    { SWIG_prefix "bncdisconnect", (swig_wrapper_func) _wrap_bncdisconnect, NULL},
    { SWIG_prefix "bnckill", (swig_wrapper_func) _wrap_bnckill, NULL},
    { SWIG_prefix "getcurrentnick", (swig_wrapper_func) _wrap_getcurrentnick, NULL},
    { SWIG_prefix "internalbinds", (swig_wrapper_func) _wrap_internalbinds, NULL},
    { SWIG_prefix "bncgetmotd", (swig_wrapper_func) _wrap_bncgetmotd, NULL},
    { SWIG_prefix "bncsetmotd", (swig_wrapper_func) _wrap_bncsetmotd, NULL},
    { SWIG_prefix "bncgetgvhost", (swig_wrapper_func) _wrap_bncgetgvhost, NULL},
    { SWIG_prefix "bncsetgvhost", (swig_wrapper_func) _wrap_bncsetgvhost, NULL},
    { SWIG_prefix "getbnchosts", (swig_wrapper_func) _wrap_getbnchosts, NULL},
    { SWIG_prefix "delbnchost", (swig_wrapper_func) _wrap_delbnchost, NULL},
    { SWIG_prefix "addbnchost", (swig_wrapper_func) _wrap_addbnchost, NULL},
    { SWIG_prefix "bncisipblocked", (swig_wrapper_func) _wrap_bncisipblocked, NULL},
    { SWIG_prefix "bnccanhostconnect", (swig_wrapper_func) _wrap_bnccanhostconnect, NULL},
    { SWIG_prefix "bncvalidusername", (swig_wrapper_func) _wrap_bncvalidusername, NULL},
    { SWIG_prefix "onchan", (swig_wrapper_func) _wrap_onchan, NULL},
    { SWIG_prefix "topic", (swig_wrapper_func) _wrap_topic, NULL},
    { SWIG_prefix "topicnick", (swig_wrapper_func) _wrap_topicnick, NULL},
    { SWIG_prefix "topicstamp", (swig_wrapper_func) _wrap_topicstamp, NULL},
    { SWIG_prefix "getchanmode", (swig_wrapper_func) _wrap_getchanmode, NULL},
    { SWIG_prefix "isop", (swig_wrapper_func) _wrap_isop, NULL},
    { SWIG_prefix "isvoice", (swig_wrapper_func) _wrap_isvoice, NULL},
    { SWIG_prefix "ishalfop", (swig_wrapper_func) _wrap_ishalfop, NULL},
    { SWIG_prefix "getchanhost", (swig_wrapper_func) _wrap_getchanhost, NULL},
    { SWIG_prefix "jump", (swig_wrapper_func) _wrap_jump, NULL},
    { SWIG_prefix "rehash", (swig_wrapper_func) _wrap_rehash, NULL},
    { SWIG_prefix "die", (swig_wrapper_func) _wrap_die, NULL},
    { SWIG_prefix "putserv", (swig_wrapper_func) _wrap_putserv, NULL},
    { SWIG_prefix "getchanjoin", (swig_wrapper_func) _wrap_getchanjoin, NULL},
    { SWIG_prefix "rand", (swig_wrapper_func) _wrap_rand, NULL},
    { SWIG_prefix "clearqueue", (swig_wrapper_func) _wrap_clearqueue, NULL},
    { SWIG_prefix "queuesize", (swig_wrapper_func) _wrap_queuesize, NULL},
    { SWIG_prefix "puthelp", (swig_wrapper_func) _wrap_puthelp, NULL},
    { SWIG_prefix "putquick", (swig_wrapper_func) _wrap_putquick, NULL},
    { SWIG_prefix "putlog", (swig_wrapper_func) _wrap_putlog, NULL},
    { SWIG_prefix "chanbans", (swig_wrapper_func) _wrap_chanbans, NULL},
    { SWIG_prefix "control", (swig_wrapper_func) _wrap_control, NULL},
    {0, 0, 0}
};

static swig_var_info swig_variables[] = {
    { SWIG_prefix "g_Encoding", 0, (swig_variable_func) _wrap_g_Encoding_get,(swig_variable_func) _wrap_g_Encoding_set},
    {0,0,0,0}
};

static swig_const_info swig_constants[] = {
    {0,0,0,0,0,0}
};

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_Tcl_Encoding[] = {{"_p_Tcl_Encoding", 0, "Tcl_Encoding *", 0, 0, 0, 0},{"_p_Tcl_Encoding", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__size_t[] = {{"_size_t", 0, "size_t", 0, 0, 0, 0},{"_size_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__ptrdiff_t[] = {{"_ptrdiff_t", 0, "ptrdiff_t", 0, 0, 0, 0},{"_ptrdiff_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_Tcl_Encoding, 
_swigt__size_t, 
_swigt__ptrdiff_t, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

#ifdef __cplusplus
}
#endif

SWIGEXPORT(int) SWIG_init(Tcl_Interp *interp) {
    int i;
    static int _init = 0;
    if (interp == 0) return TCL_ERROR;
#ifdef USE_TCL_STUBS
    if (Tcl_InitStubs(interp, (char*)"8.1", 0) == NULL) {
        return TCL_ERROR;
    }
#endif
    
    Tcl_PkgProvide(interp, (char*)SWIG_name, (char*)SWIG_version);
    
#ifdef SWIG_namespace
    Tcl_Eval(interp, "namespace eval " SWIG_namespace " { }");
#endif
    if (!_init) {
        SWIG_Tcl_LookupTypePointer(interp);
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        for (i = 0; swig_types_initial[i]; i++) {
            SWIG_PropagateClientData(swig_types[i]);
        }
        _init = 1;
    }
    for (i = 0; swig_commands[i].name; i++) {
        Tcl_CreateObjCommand(interp, (char *) swig_commands[i].name, (swig_wrapper_func) swig_commands[i].wrapper, swig_commands[i].clientdata, NULL);
    }
    for (i = 0; swig_variables[i].name; i++) {
        Tcl_SetVar(interp, (char *) swig_variables[i].name, (char *) "", TCL_GLOBAL_ONLY);
        Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_READS | TCL_GLOBAL_ONLY, (Tcl_VarTraceProc *) swig_variables[i].get, (ClientData) swig_variables[i].addr);
        Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_WRITES | TCL_GLOBAL_ONLY, (Tcl_VarTraceProc *) swig_variables[i].set, (ClientData) swig_variables[i].addr);
    }
    SWIG_InstallConstants(interp, swig_constants);
    
    return TCL_OK;
}

